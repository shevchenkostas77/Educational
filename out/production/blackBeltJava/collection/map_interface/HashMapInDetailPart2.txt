При создании HashMap мы можем задать два параметра, которые очень влияют на производительность:
1.	Initial capacity – начальный размер массива, который называется Table;
2.	Load factor – коэффициент того, насколько массив должен быть заполнен,
    после чего его размер будет увеличен вдвое;

Map<Integer, String> map2 = new HashMap<>(16, 0.75f);
16 – Initial capacity (default value);
0.75f – Load factor (default value), обязательно указывать, что этот параметр число типа float;

Когда мы указываем initial capacity 16, это означает, что после создания HashMap будет внутри него создан
массив, который называется Table, с 16 элементами, которые часто называют Baskets (если укажем больше –
будет создан Table с большим количеством Baskets и тд.)
Load factor означает, что после того как в наш HashMap будет добавлено 12 элементов, в данном
случае (16 * 0.75 = 12), размер массива будет увеличен вдвое. Будет создан массив из 32 элементов и
все элементы HashMap будут заново рехешированны (произойдет rehashing), т.е. заново, благодаря hashcode,
который содержит Node, будет определяться на какой индекс нового массива будет определен тот или иной элемент.
Чем больше мы указываем initial capacity начальный, тем больше будет памяти занимать массив, но тем меньше будут
образовываться LinkedList внутри конкретной позиции массива и поиск будет происходить быстрее. Можно пожертвовать
памятью, но улучшить производительность.
Чем больше load factor, тем больше будет экономия по памяти, но поиск элементов будет занимать больше времени.
Default value load factor = 0.75 – это золотая середина между экономией памяти и экономией времени.

Почему по умолчанию, без указания в скобках параметров, создается массив в HashMap из 16 мест и почему
не сделать, чтобы каждое значение hashcode было индексом?
Hashcode ключа может быть достаточно большим для создания массива (значение int в Java = 2_147_483_647).
Если создать такой огромный массив, то легко можно получить исключение «OutOfMemoryException» и такой
массив будет занимать «кучу» памяти даже, когда наш HashMap содержит всего 2-3 элемента. Очень важно
правильно реализовать метод hashCode() для обеспечения лучшей производительности.
Чем лучше реализован hashcode, тем лучше будут использоваться baskets («корзины»).

Общее правило следующее:
Для того, что бы вставить элемент или получить его, на это требуется константное время - О(1).
Т.е. поиск hashcode, вычисление индекса, где содержится элемент очень быстрый. В основном время занимает
прохождение по LinkedList, а прохождение по LinkedList занимает линейное - О(n). Поэтому прохождение по
LinkedList это самое времязатратная операция при поиске с помощью метода get() и вставке, с помощью метода put().
Если неправильно реализовать метод hashCode(), то могут создаваться очень длинные LinkedList и доступ к
элементам будет уже не за константное время, О(1), а будет занимать О(n). И к тому же, пустые baskets будут
занимать лишнее место в памяти.
Скорость работы методов get() и put() напрямую зависит от реализации метода hashCode(). И когда говорится,
что скорость работы HashMap – О(1), это означает, что метод hashCode() очень хорошо реализован.
Вывод: какова скорость вставки или поиска элемента в HashMap?
O(1) – в лучшем случае;
О(n) – в худшем случае;

Чтобы бороться с длинными LinkedList в массиве, начиная с Java 8, после достижения определенного порога
вместо связанных списков используются «сбалансированные деревья». В сбалансированном дереве всегда
находятся справа «больше» элемент, слева «меньше» элемент.
                                       10
                            7 		            12
                        3       9 	       11        16


Если в LinkedList скорость работы - О(n), то в «сбалансированных деревьях» - бинарный поиск, О(log n).

Очень важно в качестве ключа использовать immutable объекты. Если мы используем в качестве ключа объекты,
созданные по написанным нами классам то, следует сам класс указыть “final”, чтобы он не мог иметь наследников
и для каждого поля класса так же, указываем “final” и access modifier “private” + getter добавляем.
Если этого не сделать, то после изменения объекта, который выступает в качестве ключа, измениться и его
hashcode. В дальнейшем, если мы захотим найти этот объект – не сможем, т.к. раннее этот объект был добавлен в
массив с иным hashcode.

К примеру, в table-массиве хранится элемент “node” по индексу 3 с ключом “obj”, и допустим,
hashcode этого “obj” имеет значение 100. Изменяем любое поле объекта “obj” и в результате hashcode его
становится 101. Но элемент “node” с ключом “obj” по-прежнему находится в table-массиве по индексу 3.
И если, после изменений, попытаться найти элемент “node” с ключом “obj”, с помощью метода get(),
то результат будет null (не найден), потому что на 3-ем индексе находится элемент “node” с ключом “obj”
со старым hashcode - 100.
Сам объект не имеет понятия, что где-то, в каком-то LinkedList на него хранится ссылка.
Поэтому при изменении объекта не происходит автоматического перемещения его ссылки на другой индекс.
За такие моменты должен быть ответственен программист. Поэтому и советуется в качестве ключей использовать
immutable объекты.

HashMap – коллекция not synchronized. Ее не нужно использовать в multithreaded программировании.