Big O notation – это обозначение необходимо для описания сложности алгоритмов.
Для этого используется понятие времени, т.е. за какое время выполняются те или иные алгоритмы.
Корректнее описывать сложность алгоритма через количество операций выполняемых для достижения результатов.
Если речь идет о коллекциях, мы хотим узнать, как быстро выполняется какой-то метод коллекции,
т.е. насколько возрастает количество этих операций при увеличении количества элементов в нашей коллекции.
В Big O notation всегда рассматривается худший вариант.

Самые распространенные показателями являются:
•	О(1) – сложность порядка один или алгоритм выполняется за константное время.
    Самый эффективный, вне зависимости от количества элементов в коллекции. К примеру,
    метод get() будет работать одно и тоже время в таких коллекциях, как Array или ArrayList,
    будь то элементов три, сто или миллион.
•	О(n) – сложность порядка n или линейный алгоритм. Чем больше становится элементов в коллекции,
    тем больше необходимо шагов, чтобы выполнить какое-то действие. Количество операций линейно зависит от
    количества элементов, т.е. количество операций пропорционально возрастает по мере возрастания
    количества элементов.
•	О(log n) – это логарифмическая сложность. По скорости (по количеству шагов) хуже, чем О(1),
    но лучше О(n). К примеру, это бинарный поиск.

Почему доступ к элементу массива происходит за константное время?
Все очень просто:
int[] array = new int[4];
Создается массив и в области памяти выделяется место, в данном случае, на 16 байт (1 инт = 4 байта).
В памяти для массива выделяется место так, что все его элементы находятся радом и уже на стадии
создания массива Java знает, где в области памяти находится начало массива. К примеру, начало будет
на 102 байте. <- на этапе создания (int[] array = new int[4];) массива известно только это.
После можно элементам нашего массива придать какие-то значения:
array[0] = 3; <- начинается с 102 байта
array[1] = 8; <- начинается с 106 байта
array[2] = 5; <- начинается с 110 байта
array[3] = -6; <- начинается с 114 байта
Но с какого начинается 1, 2 и 3 элементы Java это знать не нужно. Java знает, что нулевой элемент нашего
массива находится по адресу 102 и занимает 4 байта, т.к. работаем с интом. Используя простую
формулу Java легко может найти значение n-ого элемента:

(начальная позиция массива) + (индекс элемента) * (количество, которое занимает каждый элемент)

Когда мы хотим вывести на экран array[2]:
102 + 2 * 4 = 110 байт + последующие 3 байта;
Нахождение элемента массива происходит молниеносно.
А так как массив является базой для ArrayList метод get() будет выполняться с постоянной скоростью, О(1).
Так обстоят дела с примитивными типами данных, с ссылочными немного сложнее.

String[] m = new String[4];
m[0] = “a”;
m[1] = “b”;
m[2] = “c”;
m[3] = “d”;

String является ссылочным типом, поэтому m[0] не хранит “a”, а хранит ссылку на этот объект,
т.е. создается объект в памяти, который содержит этот String и нулевому элементу массива мы присваиваем
адрес на объект “a”, например, адрес 568 (значение вот этого адреса содержится в 8-ми байтах).
Поэтому, когда мы создаем массив String из 4 элементов, этот массив будет содержать 4 ссылки
на объекты типа String, т.е. 4 кусочка памяти по 8 байт.
Допустим, выделилась память на 32 байта начиная с 100-го байта, непрерывная область памяти,
которая может/будет содержать адреса, где гранятся в памяти сами объекты. К примеру, один объект может храниться
начиная с 568 байта или 1185 байта или 8562 (размер самого объекта в данном случае не важен).
Когда выполняется эта строчка кода m[0] = “a”; создается обьект String в памяти, допустим,
создался на 568 байте и сам нулевой элемент массива будет содержать ссылку (адрес) на этот объект - “a”.
Когда выполняется эта строчка кода m[1] = “b” в памяти создается объект String и допустим,
он создается в участке памяти начиная с байта 1185, элемент по индексу 1 содержит ссылку на объект “b”.
Так же происходит со всеми последующими элементами. ***

Тут как и с примитивными типами, достигается молниеносное получения значения m[3], все по той же формуле:

(начальная позиция массива) + (индекс элемента) * (количество, которое занимает каждый элемент)

Java понимает, что начало массива “m” расположено на байте 100, следовательно
100 + 3 * 8 = начиная с 124 байта и по 131 байт хранится ссылка на 3-ий объект (элемент) и по этой ссылке,
к примеру, 8562 находится объект String. Здесь это все достигается за О(1).

Что касается вставки в конец, если мы говорим о ArrayList и у него по capacity есть еще свободные места,
то такой insert тоже происходит мгновенно – О(1).
Если нужно вставлять в конец, а в ArrayList уже нет места, т.е. size и capacity равны, тогда приходится
пересоздавать массив, переписывать все элементы из предыдущего массива, создавать новые места (capacity) и
добавлять элемент. Все это занимает O(n).
Insert в ”середину” тоже занимает O(n), т.к. часть элементов необходимо сдвинуть в правую часть на
один элемент и только после этого мы сможем добавить новый элемент.

Что касается удаления, если удаление происходит с конца, то это О(1), т.к. происходит простое удаление и
на это место можно будет добавить новый элемент, но если удаление происходит из середины, то это уже O(n),
т.к. это действие такое же, как и вставка в ”середину”, только в обратном порядке.

В LinkedList вставка в ”середину” выполняется за O(n), т.к. до определенной позиции, куда мы хотим добавить
элементы необходимо дойти (в основе лежит “цепочка”), первый элемент хранит ссылку на второй, второй на
третий и так по ссылкам до нужной позиции. По такой же причине происходит и удаление из ”середины”
элемента за O(n).
О(1) в LinkedList занимает операция добавления в самое начало. В данном случае никаких прохождений по
LinkedList не нужно, создается объект и меняются reference.

***В случае со String-массивом, в хипе хранится ссылка на массив
String[] m = new String[4];
m - в стеке.
Массив со ссылками на String-объекты и сами объекты - в хипе.