HashMap работает по принципу хеширования.
В Java хеширование – это преобразование с помощью метода hashCode() любого объекта в какое-то число (int).
Все объекты в Java наследуют стандартную реализацию hashCode функции, которая описывается в Object,
эта функция возвращает hashcode полученный путем конвертации внутреннего адреса объекта в число,
что ведет к созданию уникального кода для каждого отдельного объекта, даже если объекты идентичны
друг другу (чего не должно быть, поэтому необходимо переопределять метод hashCode()).
В классе HashMap есть внутренний класс Node, который часто называют Entry, т.к. он имплементирует
интерфейс Entry (Map.Entry<K, V>). В переводе на русский Node – узел и это то, что представляет
пару ключ-значение. Он содержит четыре поля:

static class Node<K, V> implements Map.Entry<K, V> {
    final int hash;
    final K key; - КЛЮЧ
    V value; - ЗНАЧЕНИЕ
    Node<K, V> next;
}

В основе HashMap лежит массив. Элементами данного массива являются структуры LinkedList.
Данные структуры LinkedList и заполняются элементами, которые мы добавляем в HashMap.

После создания HashMap:
Map<Student, Double> map = new HashMap<>();
Создается массив, размер которого – 16. Этот массив называется Table. Каждый элемент данного массива может
содержать несколько пар ключ-значение. Поэтому, чтобы один элемент массива мог содержать несколько пар,
эти пары ключ-значение объединяются в LinkedList. Каждый элемент массива будет содержать LinkedList (singly).
Часто элементы массива так же называются Basket – корзина, а уже в корзинах содержаться элементы HashMap –
пары Key-Value.

Когда срабатывает следующая строчка:
map.put(st1, 7.5);
в первую очередь идет проверка key = null? Если key равен null, то этот элемент сразу помещается на нулевой
(самый начальный) индекс. В данном случае это не null, поэтому находится hashcode для ключа. К примеру,
hashcode = 356. После чего, несложным алгоритмом в HashMap вычисляется на какой индекс будет помещен данный
элемент. К примеру, вычистилось, что index = 3. Это означает, что если в следующий раз мы добавим элемент с
hashcode = 356, он снова поместиться на 3-й индекс (если hashcode совпадают, то и index тоже совпадают).
Добавляется на 3-ю позицию объект NODE!

static class Node<K, V> implements Map.Entry<K, V> {
    final int hash; - HASHCODE
    final K key; - КЛЮЧ
    V value; - ЗНАЧЕНИЕ
    Node<K, V> next – ОЗНАЧАЕТ ЕСТЬ ЛИ ССЫЛКА НА СЛЕДУЮЩИЙ ЭЛЕМЕНТ;
}

static class Node<Student, Double> implements Map.Entry<K, V> {
    final int hash = 356;
    final Student key = st1;
    Double value = 7.5;
    Node<Student, Double> next = null (если нет никакого другого элемента);
}
Это первый вариант добавления. В LinkedList, который находится на этом индексе нет объектов и
наш элемент Node, который содержит всю информацию, становится первым элементом.
Далее добавим еще один элемент:
map.put(st2, 6.2);
Вычисляется его hashcode = 185 (к примеру). И вычисляется его позиционное место к примеру, его index = 7.

    final int hash = 185;
    final Student key = st2;
    Double value = 6.2;
    Node<Student, Double> next = null (пока, что это первый элемент в LinkedList на данной позиции);

Далее добавим еще один элемент:
map.put(st3, 9.3);
Вычисляется его hashcode = 562 (hashcode ключа!). И вычисляется его позиционное место и допустим его
index = 7. По формуле (вычислила Java) получился результат, что этот объект тоже должен быть на 7-ой позиции.
На 7-ом индексе уже есть один объект тогда, происходит проверка:
Hashcode одинаковы у объектов? У первого объекта, уже находящегося на данной позиции, final int hash = 356,
а у второго, который мы добавляем final int hash = 185, значит, by default – не одинаковы,
их equals не может быть true, поэтому методом equals() проверки не будет (hashcode то разные).
Тогда этот элемент, объект Node, будет добавляться в конец LinkedList на данной позиции (на 7-ую позицию).
И у предыдущего объекта поле

Node<Student, Double> next = будет не null, а ссылка на следующий объект (который вот только добавили).

static class Node<Student, Double> implements Map.Entry<K, V> {
    final int hash = 185;
    final Student key = st2;
    Double value = 6.2;
    Node<Student, Double> next = ссылка на объект Node содержащий ключ st3

            |
            V

static class Node<Student, Double> implements Map.Entry<K, V> {
    final int hash = 562;
    final Student key = st3;
    Double value = 9.3;
    Node<Student, Double> next = null (если нет никакого после него элемента, в данном случае нет);
}
Добавим еще один элемент:
map.put(st4, 7.2);
Его hashcode, допустим тоже равен 185, т.е. hashcode st2 и st4 совпал, но объекты не равны, здесь произошла
коллизия, когда hashcode двух разных объектов одинаковы. Естественно, данный элемент тоже будет помещен
в массив на позицию 7-мь. Тут снова происходит проверка для всех элементов LinkedList, который находится
на позиции 7-мь. Проверяются hashcode объектов, если совпадают, проверяются объекты на равенство с помощью
метода equals(). Естественно, что проверяются ключи! st4 и st2 равны с помощью equals()?
В данном случае не равны, переходим к следующему элементу. Hashcode равны?
В данном случае не равны (562 != 185), тогда на equals проверять смысла нет! Записывается новый объект
в конец LinkedList на позиции 7-мь.

static class Node<Student, Double> implements Map.Entry<K, V> {
    final int hash = 185;
    final Student key = st2;
    Double value = 6.2;
    Node<Student, Double> next = ссылка на объект Node содержащий ключ st3;

            |
            V

static class Node<Student, Double> implements Map.Entry<K, V> {
    final int hash = 562;
    final Student key = st3;
    Double value = 9.3;
    Node<Student, Double> next = ссылка на объект Node содержащий ключ st4;
}

            |
            V

static class Node<Student, Double> implements Map.Entry<K, V> {
    final int hash = 185;
    final Student key = st4;
    Double value = 7.2;
    Node<Student, Double> next = null (если нет никакого после него элемента, в данном случае нет);
}

Добавим еще один элемент:
map.put(st5, 3.4);
К примеру, объекты  st5 и st1 по equals равны. Для st5 находится hashcode и если st5 и st1 одинаковы,
то hashcode для st5 = 356. Вычисляется позиция, на которую новый объект будет помещен – 3.
Там уже есть элемент. Происходит проверка, hashcode одинаковы? Да! Тогда идет проверка по equals,
равны ли ключи? Да! А когда мы пытаемся добавить элемент с ключом, который уже существует,
происходить перезапись значения, но не ключа. Ключ не перезаписывается. Никакого смысла заменять ключ нет,
ведь он, по сути, равен уже имеющемуся.

Было:
static class Node<Student, Double> implements Map.Entry<K, V> {
    final int hash = 356;
    final Student key = st1;
    Double value = 7.5;
    Node<Student, Double> next = null (если нет никакого другого элемента);
}

            |
            V

Стало:
    static class Node<Student, Double> implements Map.Entry<K, V> {
    final int hash = 356;
    final Student key = st1;
    Double value = 3.4;
    Node<Student, Double> next = null (если нет никакого после него элемента);
}

Теперь перейдем к методу get()
Представим, что мы создали объект st6, с такими же полями, что и st3
map.get(st6);
Находится hashcode для ключа st6 = 562, потому что он должен быть одинаков, что и у st3.
Находится позиция, где бы содержался этот элемент, если бы он был в данном HashMap и выясняется,
что это позиция 7-мь. И далее идет проверка в LinkedList на 7-ой позиции. Сначала проверка по hashcode.
Когда находятся равный hаshcode, сравнение происходит по equals (проверяются ключи).
Если по методу equals ключи совпадают, значит найден искомый элемент и метод get() вернет значение - 9.3.


Когда мы ищем какой-то элемент в LinkedList мы должны пройтись по всем его элементам до тех пор,
пока не будет найден искомый элемент. Если есть возможность разделить большой LinkedList на маленькие
LinkedList и будем знать в каком этом маленьком LinkedList находится наш элемент, то поиск внутри
маленького LinkedList будет происходить намного быстрее.

Метод EntrySet()

for (Map.Entry<Student, Double> entry : map.entrySet()) {
	System.out.println(entry.getKey() + “:” + entry.getValue());
}

entrySet() – возвращает множество entry. Entry – это интерфейс внутренний для Map, который имплементируется
внутренним классом для Map – Node.
Node содержит hashcode, ключ, значение, ссылку на следующий элемент.
Поэтому мы можем добраться и до ключа (.getKey()), и до значения (.getValue()).