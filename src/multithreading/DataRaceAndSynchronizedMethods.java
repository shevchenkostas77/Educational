package multithreading;

public class DataRaceAndSynchronizedMethods {
    static volatile int counter = 0;
    public static void increment() {counter++;}

    public static synchronized void main(String[] args) throws InterruptedException {

        // MyRunnableImplementation runnable = new MyRunnableImplementation();

        // Thread thread1 = new Thread(runnable);
        // Thread thread2 = new Thread(runnable);
        // Thread thread3 = new Thread(runnable);

        // thread1.setName("thread1");
        // thread2.setName("thread2");
        // thread3.setName("thread3");

        // thread1.start();
        // thread2.start();
        // thread3.start();

        /*
        class Counter {
            static int count = 0;
        }

        class MyRunnableImplementation implements Runnable {

            public void increment() {
                Counter.count++;
                System.out.print(Counter.count + " ");
            }

            @Override
            public void run() {
                for (int i = 0; i < 3; i++) {
                    increment();
                }
            }
        }

        Запускаются три потока и в каждом потоке срабатывает метод increment три раза и
        выводит значение переменной count.
        Вывод:
        1 4 5 2 6 7 3 8 9

        Во-первых, нет никакой последовательности в выводимых числах, иногда выводятся, даже,
        одинаковые числа. Еще раз запускается программа.
        Вывод:
        2 4 5 3 6 7 2 8 9

        Output уже другой. Каждый новый запуск дает новый output. Проблема не заключатся в том,
        что не написано слово volatile - volatile static int count = 0;
        Запуск программы с указанным ключевым словом volatile.
        Вывод:
        2 4 5 1 6 3 8 9 7

        Все работает так же с ключевым словом volatile, как и без него. Потому, что volatile
        нужен только тогда, когда один поток меняет значение переменной, а все остальные потоки
        только читают ее.
        В данном случае нет никакой синхронизации между тремя потоками, они в один и то же момент
        времени совершают какие-то действия. Поэтому в output такая неразбериха получается.
        Поэтому volatile тут не помог, даже после того, как переменная count хранится в Main
        Memory на результат это не как не повлияло.

        Небольшое пояснение по поводу ключевого слова volatile.
        Есть Main Memory (основная память) и есть переменная count, которая хранится в Main Memory.
        Есть три потока: thread1, thread2, thread3. Например, все нормально происходило, после
        запуска потоков, и переменная count = 3. Естественно, когда выполняется операция count++,
        сначала происходит чтение значения, потом увеличение значения, потом запись значения нового
        в Main Memory, а еще в коде метода increment есть строка, которая выводит переменную на
        экран. После того, как сработал оператор ++, прочитал, изменил и записал в Main Memory
        значение переменной, чтобы вывести на экран переменную count нужно снова прочитать значение
        из Main Memory и уже выводить в консоль это значение. Допустим, все потоки прочитали
        значение переменной count - 3 (они работают параллельно и такое тоже может произойти).
        Работают на самому деле эти потоки не с одинаковой скоростью, т.к. на выполнение работы им
        могут даваться разной загруженности ядра процессора. Т.е. какой-то поток может медленнее
        сработать, какой-то очень быстро, в следствии чего может возникнуть такая ситуация:
        все они прочли значение 3, первый поток увеличил значение на 4 и записал в память, но
        еще не вывел на экран. Тем временем самый шустрый поток успел трижды проделать все свои
        операции, т.е. записать в Main Memory значение 6 и вывести на экран значения - 4, 5, 6. После
        чего первый поток, у него еще в первой итерации инструкция выводы на экран не сработала,
        он обращается к Main Memory, смотрит, что значение равно 6 и выводит на экран 6. На этом
        этапе картина в консоли: 4 5 6 6. Третий поток, который, к примеру, медленно работает меняет
        наконец-таки значение с 3 на 4, записывает в память и выводит на экран 4. На этом этапе картина
        в консоли: 4 5 6 6 4 и в памяти значение 4. Эта ситуация может запросто произойти. Когда
        два и более потоков меняют и обращаются вообще к переменной, то можно столкнуться с такой
        ситуаций, которая называется - Data race (с англ. гонка данных). Потоки как будто учувствуют
        в гонке и пытаются побыстрее проделать свои операции. У какого-то потока получается быстрее,
        а у какого-то потока медленнее и все зависит от множества факторов.
        */
        R runnable = new R();
        Thread thread1 = new Thread(runnable);
        Thread thread2 = new Thread(runnable);

        thread1.start();
        thread2.start();

        thread1.join();
        thread2.join();

        System.out.println(counter);
        /*
        Если запустить код без join, то начнется обработка потоков thread1 и thread2, они начнут
        свою работу и сразу же выведется переменная counter. Нужно, чтобы поток
        DataRaceAndSynchronizedMethods дождался окончания работы потоков thread1 и thread2 и
        лишь потом вывел counter.
        */
        /*
        Вывод:
        1818
        Тут происходит Data race (гонка данных) из-за которой выводится неверный результат. Это
        происходит потому, что работы данных потоков не синхронизирована, они друг от друга
        никак не зависят, они работают параллельно, делают свою работу, не обращая внимания на то,
        что могут помешать друг другу.

        Data race - это проблема, которая может возникнуть когда два и более потоков обращаются
        к одной той же переменной и как минимум один поток ее изменяет.

        Опять-таки, поставив ключевое слово volaile - volaile static int counter = 0; это ни на что
        не повлияет. Все равно два потока изменяют данные и иногда выводится верный результат, но
        нет никаких гарантий, что выведется верный ответ.

        Чтобы избегать этой проблемы необходимо быть уверенным в том, что в одно и тоже время с
        переменой counter, т.е. чтение этой переменной и запись в нее нового значения в одно и тоже
        время будет производиться только одним потоком. Т.е. к этой переменной два и более потока
        не могли одновременно обратиться. Можно поставить lock (с англ. замок) и добиться того, что
        метод increment в одно и тоже время работает только для одного потока. Потому, что
        важно, чтобы переменная counter увеличивалась только одним потоком в один и тот же момент времени.
        Ставится, грубо говоря замок на необходимый участок кода и теперь в одно и тоже время только один
        поток сможет выполнять метод increment или какой-то участок кода, на который был поставлен замок

        Как это работает?
        Есть, к примеру, метод increment, в котором есть какая-то логика (counter++;) и три потока:
        thread1, thread2, thread3, которые хотят забежать в тело метода. Если необходимо на весь метод
        increment поставить замок, тогда только один поток будет исполнять тело метода incremant, а
        все остальные потоки будут стоять и ждать. Т.е., к примеру, сработал быстрее всех поток
        thread1, забежал в тело метода increment, после этого устанавливается замок на метод increment для всех
        других потоков. И пока thread1 не выполнит всю необходимую ему работу, замок открыт не будет. А
        потоки thread2 и thread3 будут стоять и ждать завершения работы потока thread1. В этом и принцип
        синхронизации.
        После того, как поток thread1 завершил свою работу, замок открывается и в метод increment пытаются
        зайти потоки thread2 и thread3. Какому из них больше "повезет" или приоритет у которого выше,
        этот поток снова "забегает" в тело метода, ставит замок, допустим, это thread2 и тогда thread3
        снова стоит и ждет до тех пор, пока поток thread2 не выполнит всю свою работу. После того, кук
        thread2 выполняет свою работу и замок освобождается, поток thread3 заходит в тело метода increment
        и делает так же свою работу. Таким образом доступ (access) к переменной counter в один и тот же
        момент времени есть только у одного потока. Это и есть принцип синхронизации и достигается за счет
        одного ключевого слова synchronized. Т.е. в данном случае необходим добавить слово synchronized в
        описание метода increment - public static synchronized void increment() {counter++;} и после этого
        операцию counter++; в один момент времени может выполнять либо поток thread1, либо поток thread2.
        Каждый из этих потоков будут заходит в метод increment 1_000 раз, т.к.

        @Override
        public void run() {
            for (int i = 0; i < 1_000; i++) {
                Main.increment();
            }

        Допустим, сначала забежал поток thread1 выполнил метод increment первый раз, потом забежал поток
        thread2 выполнил свою работу, потом снова поток thread2 забежать. Из-за того, что эта работа
        очень быстрая (увеличение на единицу), запросто может быть такое, что поток thread2 окажется
        более шустрым, чем поток thread1 и подряд выполнит, к примеру, 10 раз метод increment, а поток
        thread1 будет ждать. Какой поток будет шустрее, тот и будет заходить в метод, ставить замок и
        только выходя из метода открывать этот замок.

        Пример метода:
        public synchronized void nameMethod() {
            method body;
        }

        Снчачало пишеться access modifiers, после клчевое слово synchronized и тд.

        Переменные могут быть volatile, но synchronized keyword абсолютно к ним не подходит, т.е.

        написать вот так:

                synchronized int counter = 0;

        вместо:

                volatile int counter = 0;

        так нельзя!
        */
    }
}

class R implements Runnable {

    @Override
    public void run() {
        for (int i = 0; i < 1_000; i++) {
            DataRaceAndSynchronizedMethods.increment();
        }
    }
}



// class Counter {
//     static int count = 0;
// }

// class MyRunnableImplementation implements Runnable {

//     public void increment() {
//         Counter.count++;
//         System.out.print(Counter.count + " ");
//     }

//     @Override
//     public void run() {
//         for (int i = 0; i < 3; i++) {
//             increment();
//         }
//     }
// }