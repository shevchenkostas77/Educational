package multithreading;

/*
Иногда при взаимодействии потоков стоит вопрос об извещении одних потоков о действиях других потоков. Например,
действия одного потока могут зависеть от результата действия другого потока. И надо как-то известить один поток,
что второй поток произвел какую-то работу и для подобных ситуаций у класса Object определено рад методов. Т.е.
для извещения потоком других потоков о своих действиях часто используются следующие методы:

wait (с англ. ждать) - освобождает монитор и переводит вызывающий поток в состояние ожидания до тех пор, пока
другой поток не вызовет метод notify() или notifyAll()
notify (с англ. уведомлять) - НЕ освобождает монитор и будит поток, у которого ранее был вызван метод wait();
notifyAll - НЕ освобождает монитор и будит все потоки, у которых ранее был вызван метод wait();

Пусть будет магазин - Market, в котором продают хлеб. На витрине в одно и то же время может находиться не больше
5 буханок хлеба. Таким образом, если на витрине 5 буханок хлеба, то производитель не может доложить еще хлеб и должен
ждать, когда покупатель купит хотя бы 1 буханку хлеба. После чего хлеб можно докладывать на витрину. Что касается
покупателя, то понятное дело, что если на витрине нет хлеба, то он должен ждать пока хлеб не появится. И
допустим, что в день печется, для данного магазина, всего 10 буханок хлеба. Производитель хлеба - producer, он
производит хлеб, а любителя поесть хлеб - потребитель (англ. consumer). Каждый из них будет представлять отдельный
поток в программе и они будут общаться между собой с помощью методов wait и notify. Так, если хлеба нет на
витрине, поток consumer будет ожидать вызывая метод wait. Когда производитель добавит хотя бы один хлеб, он же
(производитель) будет вызывать метод notify, давая понять потребителю, что хлеб появился и твой поток может
"просыпаться". Но вызов метода notify производителем не заставляет его поток уснуть, он может производить дальше
свой хлеб. Метод notify просто будит поток consumer, но сам не засыпает. А когда должен засыпать поток производителя?
Если хлеба стало 5 буханок на витрине, то производителю делать нечего, т.е. он не может добавить на прилавок еще
один хлеб и тогда, он может поспать, вызвав метод wait. Поток потребителя, в свою очередь, разбудит поток
производителя тогда, когда хотя бы 1 хлеб будет куплен. Если consumer возьмет один хлеб и хлеба станет 4 буханки,
тогда он может вызвать метод notify и "сказать" потоку producer "просыпайся, ты можешь продолжить класть
хлеб на витрину".
 */

public class MethodsWaitAndNotify {
    public static void main(String[] args) {
        Market market = new Market();
        // Оба synchronized метода в классе Market. Поэтому именно его объект и используется для синхронизации.

        Producer producer = new Producer(market); // создается объект производителя
        Consumer consumer = new Consumer(market); // создается объект потребителя

        Thread thread1 = new Thread(producer); // передается Runnable producer в поток
        Thread thread2 = new Thread(consumer); // передается Runnable consumer в поток

        thread1.start();
        thread2.start();
    }
}

class Market {
    private int breadCount = 0;

//    private final Object lock = new Object();

    // Метод симулирующий взятие хлеба потребителем
    public synchronized void getBread() {
//        synchronized (lock) {
        while (breadCount < 1) { // если хлеба не осталось нужно ждать
            try {
                wait(); // метод выбрасывает InterruptedException
//                lock.wait(); // если использовать другой объект для синхронизации, а не this
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        breadCount--; // если хлеб есть, потребитель его берет (уменьшается кол-во на единицу)
        System.out.println("Потребитель купил 1 хлеб");
        System.out.println("Количество хлеба в магазине = " + breadCount);
        /*
        После того как потребитель взял хотя бы один хлеб необходимо вызвать метод notify, тем самым
        сообщить производителю, что количество хлеба уменьшилось на единицу и можно добавлять хлеб на витрину
         */
        notify();
//        lock.notify(); // если использовать другой объект для синхронизации, а не this
        // Монитор освободится как только метод getBread завершит работу
    }

    // Метод, который будет выполняться производителем
    public synchronized void putBread() {
        // на витрине может быть не больше 5 буханок хлеба
        while (breadCount == 5) { // когда хлеба будет 5 буханок
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        // Если хлеба на витрине не 5 буханок, тогда хлеб добавляет производитель
        breadCount++;
        System.out.println("Производитель добавил на витрину 1 хлеб");
        System.out.println("Количество хлеба в магазине = " + breadCount);
        // После необходимо известить потребителя, что хлеб добавился и можно его купить
        notify();
        // Монитор освободится как только метод putBread завершит работу
    }
}

class Producer implements Runnable {
    Market market;

    Producer(Market market) { // конструктор, с помощью которого будет добавляться market производителю
        this.market = market;
    }

    @Override
    public void run() {
        // производитель в день производит 10 буханок хлеба
        for (int i = 0; i < 10; i++) {
            market.putBread();
        }
    }
}

class Consumer implements Runnable {
    Market market;

    Consumer(Market market) {
        this.market = market;
    }

    @Override
    public void run() {
        /*
        если производитель производит 10 буханок хлеба в день для этого магазина, то потребитель тоже может
        купить 10 буханок хлеба в этом магазине.
         */
        for (int i = 0; i < 10; i++) {
            market.getBread();
        }
    }
}

/*
Есть класс Market, в нем переменная breadCount, которая будет показывать количество хлеба, которое есть в
магазине:
        class Market {
            private int breadCount = 0;
            ...
        }

Метод getBread - им будет пользоваться потребитель. Этот метод уменьшает количество хлеба на 1,
выводит сообщение, что потребитель купил один хлеб, количество стало в магазине таким-то и при помощи
метода notify идет оповещение производителя, что хлеба стало меньше, можно добавить хлеб на витрину
(монитор освободится как только метод getBread завершит работу):

        breadCount--; // если хлеб есть, потребитель его берет (уменьшается кол-во на единицу)
        System.out.println("Потребитель купил 1 хлеб");
        System.out.println("Количество хлеба в магазине = " + breadCount);
        // После того как потребитель взял хотя бы один хлеб необходимо вызвать метод notify, тем самым
        // сообщить производителю, что количество хлеба уменьшилось на единицу и можно добавлять хлеб на витрину
        notify();

Еcли же на витрине нет хлеба:
        while (breadCount < 1) { // если хлеба не осталось
            try {
                wait(); // метод выбрасывает InterruptedException
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
тогда поток, который вызывает getBread, а этим потоком будет consumer, он должен ждать (метод wait), а когда
происходит ожидание монитор - освобождается.

Есть метод putBread, которым будет пользоваться производитель. Он добавляет 1 хлеб в магазин на витрину,
выводит сообщение о том, что производитель добавил на витрину хлеб, количество хлеба стало таким-то и
извещает поток потребителя, что хлеб был добавлен, можно его покупать:

        // Если хлеба на витрине не 5 буханок, тогда хлеб добавляет производитель
        breadCount++;
        System.out.println("Производитель добавил на витрину 1 хлеб");
        System.out.println("Количество хлеба в магазине = " + breadCount);
        // После необходимо известить потребителя, что хлеб добавился и можно его купить
        notify();

Если же количество хлеба 5 буханок на витрине, тогда производитель не может доложить на витрину хлеб и его
поток начинает ждать (при помощи метода wait). Ждать, чтобы количество хлеба на витрине уменьшилось:

        while (breadCount == 5) { // когда хлеба будет 5 буханок
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

Было создано два класса: Producer и Consumer, которые имплементируют функциональный интерфейс Runnable.
Передается в конструктор этих классов market, чтобы они знали с каким магазином работают и 10 раз
производитель будет добавлять хлеб, а потребитель будет брать хлеб.

В методе main был создан объект магазина:

        Market market = new Market();

созданы объекты Producer и Consumer:

        Producer producer = new Producer(market); // создается объект производителя
        Consumer consumer = new Consumer(market); // создается объект потребителя

и созданы два потока:

        Thread thread1 = new Thread(producer); // передается Runnable producer в поток
        Thread thread2 = new Thread(consumer); // передается Runnable consumer в поток

Методы getBread и putBread синхронизированы и естественно, синхронизация происходит по объекту this.
This - это какой-то созданный Market. В методе main был создан объект типа Market и синхронизация будет
идти по этому объекту:

        Market market = new Market();
        Producer producer = new Producer(market); // создается объект производителя
        Consumer consumer = new Consumer(market); // создается объект потребителя
        Thread thread1 = new Thread(producer); // передается Runnable producer в поток
        Thread thread2 = new Thread(consumer); // передается Runnable consumer в поток

Т.е. потоки producer (thread1) и consumer (thread2) будут синхронизированы по одному и тому же объекту -
market. Поэтому они одновременно работать не смогут, а именно не смогут одновременно работать методы getBread и
putBread.

Запуск программы и вывод на экран:

        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 1
        Потребитель купил 1 хлеб
        Количество хлеба в магазине = 0
        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 1
        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 2
        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 3
        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 4
        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 5
        Потребитель купил 1 хлеб
        Количество хлеба в магазине = 4
        Потребитель купил 1 хлеб
        Количество хлеба в магазине = 3
        Потребитель купил 1 хлеб
        Количество хлеба в магазине = 2
        Потребитель купил 1 хлеб
        Количество хлеба в магазине = 1
        Потребитель купил 1 хлеб
        Количество хлеба в магазине = 0
        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 1
        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 2
        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 3
        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 4
        Потребитель купил 1 хлеб
        Количество хлеба в магазине = 3
        Потребитель купил 1 хлеб
        Количество хлеба в магазине = 2
        Потребитель купил 1 хлеб
        Количество хлеба в магазине = 1
        Потребитель купил 1 хлеб
        Количество хлеба в магазине = 0

Неизвестно какой поток начал свою работу, т.к., возможно, первым начал работу поток потребителя, но он
проверил и увидел, что хлеба пока что нет в магазине (private int breadCount = 0;) и начал ждать (сработал
метод wait). После чего монитор объекта this освобождается и тогда начинает работать поток производителя.
Поток производителя произвел 1 буханку хлеба (т.к. условие в while блоке не выполнилось), вывел два сообщения
на экран (добавлен на витрину хлеб и остаток в магазина) и после этого он проинформировал об этом уснувший
поток потребителя ("я добавил хлеб, ты можешь уже не ждать и купить хлеб"). После окончания метода putBread
монитор объекта this освобождается и в этот момент уже бодрствуют ОБА потока и поток потребителя, и поток
производителя. Какой из них первым захватит монитор - НЕВОЗМОЖНО предсказать, они "борются" за этот монитор.
В данном output монитор был захвачен потоком потребителя:

        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 1
        Потребитель купил 1 хлеб
        Количество хлеба в магазине = 0

Он проверил есть ли хлеб, а хлеб уже был, потому он взял один хлеб и вывел два сообщения на экран (сколько
взял хлеба и сколько осталось хлеба в магазине). После этих действий поток потребителя вызывает метод notify.
В данном случае этот метод notify холостой, потому, что поток производителя не спит, а активный и ждет своей
очереди. После того, как вызвался метод notify, закончился метод getBread и монитор this снова освободился.
Возможно, после этого монитор был занят потоком consumer, но хлеба в магазине уже нет и поэтому потребитель
снова начал ждать. Пока поток consumer ждет (монитор становился свободным, метод wait освобождает монитор),
вызывается поток производителя и производитель добавляет один хлеб на витрину, извещает при помощи метода
notify потребителя, поток потребителя становится активным и после окончания метода putBread, монитор объекта
this снова освобождается и первым его успевает захватить снова производитель:

        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 1
        Потребитель купил 1 хлеб
        Количество хлеба в магазине = 0
        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 1
        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 2

Производитель добавляет снова один хлеб на витрину, снова вызывает метод notify, этот метод снова срабатывает
в холостую, потому что поток потребителя активный, он не ждет и монитор this опять освобождается. И в примере
видно, что его снова успевает захватить производитель:

        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 1
        Потребитель купил 1 хлеб
        Количество хлеба в магазине = 0
        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 1
        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 2
        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 3

Он опять производит хлеб, в следующий раз снова производитель захватывает монитор this:

        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 1
        Потребитель купил 1 хлеб
        Количество хлеба в магазине = 0
        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 1
        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 2
        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 3
        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 4

И в следующий раз поток производителя захватывает монитор this:

        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 1
        Потребитель купил 1 хлеб
        Количество хлеба в магазине = 0
        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 1
        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 2
        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 3
        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 4
        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 5

Он производит 5 буханок хлеба и витрина оказывается полностью заполненной (это максимум). Возможно, в следующий
раз поток производителя снова захватил монитор this, но в цикле while проверилось условие - количество буханок
хлеба равно 5? Да, равно 5. Поэтому поток производителя должен ждать (запускается метод wait), он освобождает
монитор this и начинает работать поток потребителя.
Поток потребителя все по той же схеме забирает 1 буханку хлеба, информирует производителя о том, что
производитель может становится снова активным. После выхода потока потребителя из метода getBread монитор
this становится свободным и уже снова два потока борются за монитор, но поток потребителя успевает быстрее
сработать и занимает, опять таки, монитор (и следующие три раза тоже):

        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 1
        Потребитель купил 1 хлеб
        Количество хлеба в магазине = 0
        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 1
        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 2
        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 3
        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 4
        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 5
        Потребитель купил 1 хлеб
        Количество хлеба в магазине = 4
        Потребитель купил 1 хлеб
        Количество хлеба в магазине = 3
        Потребитель купил 1 хлеб
        Количество хлеба в магазине = 2
        Потребитель купил 1 хлеб
        Количество хлеба в магазине = 1
        Потребитель купил 1 хлеб
        Количество хлеба в магазине = 0

после чего в методе getBread срабатывает условия while цикла (breadCount < 1) - хлеба больше нет и поток
потребителя начинает ждать (срабатывает метод wait), монитор this освобождается и производитель производит
еще 4 раза хлеб, а после потребитель, по той же схеме, эти 4 буханки хлеба забирает:

        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 1
        Потребитель купил 1 хлеб
        Количество хлеба в магазине = 0
        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 1
        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 2
        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 3
        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 4
        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 5
        Потребитель купил 1 хлеб
        Количество хлеба в магазине = 4
        Потребитель купил 1 хлеб
        Количество хлеба в магазине = 3
        Потребитель купил 1 хлеб
        Количество хлеба в магазине = 2
        Потребитель купил 1 хлеб
        Количество хлеба в магазине = 1
        Потребитель купил 1 хлеб
        Количество хлеба в магазине = 0
        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 1
        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 2
        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 3
        Производитель добавил на витрину 1 хлеб
        Количество хлеба в магазине = 4
        Потребитель купил 1 хлеб
        Количество хлеба в магазине = 3
        Потребитель купил 1 хлеб
        Количество хлеба в магазине = 2
        Потребитель купил 1 хлеб
        Количество хлеба в магазине = 1
        Потребитель купил 1 хлеб
        Количество хлеба в магазине = 0

После чего потоки останавливают свою работу. Все 10 раз методы putBread и getBread были выполнены.
Если запустить еще раз код, то с высокой долей вероятности будет совсем инной output, т.к. не возможно
предсказать какой поток захватит монитор. Все дело в том, что когда освобождается монитор this в методе
getBread или putBread без разницы, если оба потока активны, то любой из них может захватить этот монитор,
даже тот поток, который только что его отпустил (освободил).
Как выше было написано, в некоторых случаях вызовы метода notify будь то из метода getBread или будь то
из метода putBread бывают холостыми. Т.е. поток, не из которого вызывается метод notify, не находится в
состоянии ожидания, он тоже активный, просто монитор занят не им, тогда вызов метода notify бывает
холостым.

Методы weit и notify вызываются только из синхронизированного контекста, т.е. из синхронизированного блока
или метода. Данные методы вызываются на объекте, который используется для создания lock в synchronized
методах (или блоках). Т.е. когда пишется в методе или блоке методы просто wait или просто notify, то как
и любой метод они срабатывают на this -> this.wait(); this.notify(); И в данном примере синхронизация
тоже идет по объекту this. Если же использовать synchronized блок и в нем указать, что lock на мониторе
какого-то другого объекта, то методы wait и notify должны быть вызываны используя тот объект, на котором
идет синхронизация -> lock.wait(); lock.notify(); На мониторе какого объекта происходит синхронизация, то
на том же самом объекте необходимо вызывать методы wait и notify.

Метод wait может принимать в параметр миллисекунды (1 сек = 1_000 миллисекунд). Если указать миллисекунды
в параметре метода, то этот поток (когда сработает этот метод), который ждет, будет ждать максимум по
указанному времени. Т.е. если в течении указанного времени другой какой-то поток не вызовет метод notify
и этот поток не станет активным, то через указанное время он перестанет ждать и станет активным. Какое
из этих двух событий быстрее сработает, то событие и переведет поток в активное состояние.

Почему метод wait помещается в while loop, а не в if loop?
Это рекомендация из Java Documentation, говорится, что поток может, оказывается, проснуться, в очень редких
случаях, без notify и тогда необходимо быть уверенным, что условие while проверится еще раз. Если просыпания
потока было случайным, то снова сработает метод wait и поток продожит ждтать.
 */

/*
Примечания.
Есть N спящих потоков, метод notify() разбудит один из них, причем рандомно. А notifyAll() разбудит все.
Возможности точечно разбудить один единственный нужный поток нет.

Монитор есть как у класса, так и у объекта. Эти мониторы разные. Поэтому при использовании мониторов на
объектах и классах, они никак не переплетаются.
 */