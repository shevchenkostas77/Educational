package multithreading;

/*
Deadlock описывает ситуацию, когда два и более потоков заблокированны навсегда
ожидая друг друга.
Deadlock - ситуация, когда 2 или более потоков залочены навсегда, ожидают друг
друга и ничего не делают.
Это возникает, когда несколько потоков используют синхронизацию на нескольких
объектах и эти потоки используют синхронизацию на этих объектах не в одинковом
порядке.
*/

public class DeadlockLivelockLockStarvation {
    public static final Object lock1 = new Object();
    public static final Object lock2 = new Object();

    public static void main(String[] args) {
        Thread10 thread10 = new Thread10();
        Thread20 thread20 = new Thread20();

        thread10.start();
        thread20.start();
    }

}

class Thread10 extends Thread {
    @Override
    public void run() {
        System.out.println("Thread10: Попытка захватить монитор объекта lock1");
        synchronized (DeadlockLivelockLockStarvation.lock1) { // lock на объекте Deadlock
            // Если поток Thread10 внутри synchonized блока, то он сумел захватить монитор
            System.out.println("Thread10: Монитор объекта lock1 захвачен");
            // Дальше нужно провести синхронизацию используя монитор объекта lock2
            System.out.println("Thread10: Попытка захватить монитор объекта lock2");
            synchronized (DeadlockLivelockLockStarvation.lock2) {
                System.out.println("Thread10: Мониторы объектов lock1 " +
                        "и lock2 захвачены");
            }
        }
    }
}

class Thread20 extends Thread {
    @Override
    public void run() {
        System.out.println("Thread20: Попытка захватить монитор объекта lock2");
        synchronized (DeadlockLivelockLockStarvation.lock2) {
            System.out.println("Thread20: Монитор объекта lock2 захвачен");
            System.out.println("Thread20: Попытка захватить монитор объекта lock1");
            synchronized (DeadlockLivelockLockStarvation.lock1) {
                System.out.println("Thread20: Мониторы объектов lock1 " +
                        "и lock2 захвачены");
            }
        }
    }
}

/*
Thread20 в своем методе run пытается в первую очередь захватить монитор объекта
lock2 (первый synchronized блок). Если поток находится внутри synchronized блока,
то Thread20 сумел захватил монитор объекта lock2, и выведется сообщение: "Thread20:
Монитор объекта lock2 захвачен". Потом он пытается захватить монитор объекта lock1
(выводится сообщение: "Thread20: Попытка захватить монитор объекта lock1") и если
поток Thread20 зашел во второй synchronized блок метода run, тогда Thread20 сумел
захватить монитор объекта lock1 и выводит сообщение: "Thread20: Мониторы объектов
lock1 и lock2 захвачены"

Запускается код.
Вывод:
        Thread20: Попытка захватить монитор объекта lock2
        Thread20: Монитор объекта lock2 захвачен
        Thread20: Попытка захватить монитор объекта lock1
        Thread20: Мониторы объектов lock1 и lock2 захвачены
        Thread10: Попытка захватить монитор объекта lock1
        Thread10: Монитор объекта lock1 захвачен
        Thread10: Попытка захватить монитор объекта lock2
        Thread10: Монитор объектов lock1 и lock2 захвачены

Поток Thread20 оказался намного проворнее, чем Thread10. Он сначала захватил
монитор объекта lock2, потом захватил монитор объекта lock1, т.е. у него под
контролем мониторы обоих объектов. В это время Thread10 просто ждет, когда
мониторы объектов lock1 и lock2 освободятся и после освобождения поток Thread10
захватывает lock1, а потом и lock2. Программа нормально срабатывает. Раз на раз
не приходится и сможет произойти такая ситуация, что программа попадет в deadlock,
в "мертвый замок" и никогда больше не завершится.

Запускается код.
Вывод:
        Thread10: Попытка захватить монитор объекта lock1
        Thread10: Монитор объекта lock1 захвачен
        Thread20: Попытка захватить монитор объекта lock2
        Thread20: Монитор объекта lock2 захвачен
        Thread10: Попытка захватить монитор объекта lock2
        Thread20: Попытка захватить монитор объекта lock1

Почему так происходит?
Поток Thread10 пытается захватить монитор объекта lock1 и успешно захватывает:

        Thread10: Попытка захватить монитор объекта lock1
        Thread10: Монитор объекта lock1 захвачен

т.е. поток Thread10 в этот момент находится внутри первого synchronized блока
метода run класса Thread10, а тем временем параллельно с потоком thread10
работает поток Thread20. Поток Tread20, в первую очередь, пытается захватить
монитор объекта lock2 и как видно с последнего output успешно его захватывает:

        Thread10: Попытка захватить монитор объекта lock1
        Thread10: Монитор объекта lock1 захвачен
        Thread20: Попытка захватить монитор объекта lock2
        Thread20: Монитор объекта lock2 захвачен

и поток Thread20 находится внутри первого synchronized блока метода run класса
Thread20. И теперь Thread10 пытается захватить монитор объекта lock2, но Lock2 то
уже занят потоком Thread20, а Thread20 пытается захватить монитор объекта lock1,
который уже занят потоком Thread10. Получается ситуация, когда два потока ждут
друг друга до бесконечности и не отпускают захваченные мониторы. Т.е. Thread20
ждет когда освободится монитор lock1, а Thread10 ждет когда освободится монитор
объекта lock2. Эти потоки ждут и ничего не делают. Но иногда возникают ситуации,
что какой-то поток более шустрее и deadlock не происходит.

Как исправить данную ситуацию?
Нужно изменить порядок lock, т.е. если поток Thread10 блокирует в порядке сначала
lock1 (synchronized (lock1) { ... }), потом lock2 (synchronized (lock1) { ... }),
то чтобы не возник deadlock, поток Thread20 должен делать блокировку в таком же
порядке. Таким образом, еслт сделать порядки lock одинаковыми для всех потоков,
то никогда не возникнет deadlock - ситуация. Потому, что какой из потоков первый
сделает lock в первом synchronized блоке (lock объекта lock1), то тот же поток
сделает lock во втором synchronized блоке (lock лбъекта lock2) и завершит свою
работу. Поэтому, когда происходит работа с блоками, где синхронизация идет по
монитору больше чем одного объекта, то нужно синхронизироваться в одинаковом порядке
для разных методов.
*/

/*
Livelock - ситуация, когда 2 или более потоков залочены навсегда, ожидают друг
друга, проделывают какую-то работу, но без какого-либо прогресса.
Представим, что есть мост, мост с дорогой. Есть машина с одной стороны моста и
есть машина с другой стороны моста. Эти машины - машины-роботы, управление этих
машин происходит при помощи искусственного интеллекта. Представим, что на этом
мосту дорога для автомобилей очень узкая и по ней может проехать только одна
машина. Машины по бокам моста не видят заранее друг друга. Суть машины робота
заключается в том, чтобы эта машина въезжает на мост и видит, что едет на
встречу другая машина, то машина-робот должна уступить дорогу, т.е. вернуться
назад (в начало моста), подождать, чтобы другая машина проехала и только после
этого продолжить свое движение. Представим, что две робот-машины (с обеих
краев моста) забираются на этот мост. Что произойдет тогда?
Они увидят друг друга и у каждой из них сработает команда, что нужно уступить
дорогу. Обе машины возвращаются в исходное положение. Ждут какое-то время, видят,
что другая машина не проехала и снова поднимаются на мост. И процесс повторяется
снова. Это называется Livelock и будет работать бесконечно, как и DeadLock, но
совершается какае-то работа, прогресс которой равен нулю.
Еще один пример. Есть потоки T1 и Т2. И есть какой-то ресурс. Поток Т1 делает
какие-то изменения в этом ресурсе, а поток Т2 эти изменения постоянно стирает.
Т.е. потоки Т1 и Т2 вроде бы работают, но конечного прогресса у них нет. Они
будут так работать "вечно". Отличие от Deadlock в том, что при Deadlock-е потоки
ничего не делают, просто ждут, а в LiveLock-e проделывают какую-то работу, но
напрасно.
*/

