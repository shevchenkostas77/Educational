package multithreading;

/*
Допустим есть задание - написать два письма, к примеру, маме и другу. Естественно, написать эти два письма не выйдет
одновременно. Т.е. и левой и правой рукой одновременно писать не получится, конечно же, если человек не амбидекстр
(врождённое или выработанное в тренировке равное развитие функций обеих рук, без выделения ведущей руки, и способность
человека выполнять двигательные действия правой и левой рукой с одинаковой скоростью и эффективностью). В синхронном
программировании все задания выполняются последовательно, друг за другом. Т.е. идет написания сначала первого письма,
затем идет написание второго письма. Друг за другом - это синхронное программирование. Пока первое письмо не будет
написано, к написанию второго письма приступить не получится.

         В коде ниже используется синхронное программирование:
         public static void main(String[] args) {
            System.out.println("Start"); <- сначала выполняется эта работа

            for (int i = 0; i < 10; i++) { <- затем выполняется эта работа
                System.out.println(i);

            System.out.println("End");  <- и только после выполняется эта работа
            Можно считать, что в этом коде пишется три письма

Нужно не путать понятие синхронность в программировании, к примеру, с синхронным плаванием, когда несколько
спортсменов делают одни и те же движения одновременно. В программировании понятие синхронно означает последовательно,
друг за другом.

Допустим есть задание, что нужно сделать бутерброд и постирать белье. Можно бросить свое грязное белье в стиральную
машинку и не дожидаясь пока закончится стирка начать готовить бутерброд. Тут эти два действия происходят асинхронно.
В асинхронном программировании, когда одна работа выполняется, в данном случае это стирка белья, можно переключиться
на другую работу, в данном примере это готовка бутерброда. Асинхронное программирование помогает достичь concurrency
потому, что в синхронном программировании не делаются вещи одновременно, а делаются последовательно. В асинхронном
программировании с помощью concurrency достигается возможность выполнять сразу несколько заданий. Если использовать
асинхронное программирование на компьютере с многоядерным процессором, тогда можно достичь параллельности выполнения
заданий. Вот в чем разница в synchronous и asynchronous.
Еще раз, синхронное программирование это когда задания выполняются последовательно, чтобы выполнить задание №2,
необходимо дождаться окончания выполнения задания №1. В асинхронном программировании можно выполнять сразу несколько
задач и если используется многоядерный процессор эти несколько задач могут выполняться параллельно. А если используется
одноядерный процессор при асинхронном программировании, тогда будет выполнение заданий происходить как бы параллельно
(сначала до какого-то момента выполняется задание №1, после происходит остановка и переключение на задание №2 и это
задание выполняется до определенного момента, затем снова остановка и переключение на задание №1, теперь снова задание
№1 выполняется до какого-то определенного момента, затем снова остановка и переключение на задание №2 и тд.).
Как итог вышенаписанного:

В синхронном программировании задачи выполняются последовательно друг за другом.

В асинхронном программировании каждая следующая задача НЕ ждет окончания выполнения предыдущей. Асинхронное
программирование помогает достичь concurrency.
 */

public class SynchronousAndAsynchronous extends Thread {
    @Override
    public void run() {
        for (int i = 0; i <= 5; i++) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + " " + i);
        }
    }
    public static void main(String[] args) {
        Thread thread1 = new Thread(new MyRunnable1());
        SynchronousAndAsynchronous thread2 = new SynchronousAndAsynchronous();

        thread1.start();
        thread2.start();

//        Вывод (запуск №1):        Вывод (запуск №2):
//        Thread-1 0                Thread-0 0
//        Thread-0 0                Thread-1 0
//        Thread-1 1                Thread-0 1
//        Thread-0 1                Thread-1 1
//        Thread-0 2                Thread-0 2
//        Thread-1 2                Thread-1 2
//        Thread-1 3                Thread-0 3
//        Thread-0 3                Thread-1 3
//        Thread-1 4                Thread-0 4
//        Thread-0 4                Thread-1 4
//        Thread-1 5                Thread-0 5
//        Thread-0 5                Thread-1 5
        /*
        При запуске №1
        сначала выполнялся поток Thread-1, после поток Thread-0
        далее выполнялся поток Thread-1, после поток Thread-0
        далее выполнялся поток Thread-0, после поток Thread-1
        При запуске №2
        сначала выполнялся поток Thread-0, после поток Thread-1
        далее выполнялся поток Thread-0, после поток Thread-1
        далее выполнялся поток Thread-0, после поток Thread-1
        Если сравнить эти два output, даже первые две сроки достаточно, видна очевидная разница. При нескольких
        запусках программы output будут разными, т.е. в каком-то output сначала поток Thread-1 срабатывает, в
        каком-то другом output сначала срабатывает поток Thread-0. Это происходит потому, что потоки работают
        АСИНХРОННО, нет никакого порядка в их исполнении, т.е. output не предсказуем в данном случае. Другими словами
        это поведение потоков называется недетерминированные. Поведение недетерминированное потому, что потоки
        Thread-0 и Thread-1 выполняют свою работу абсолютно независимо друг от друга. В программах, где используется
        асинхронное программирование программист не может заранее определить порядок выполнения потоков.
         */
    }
}
class MyRunnable1 implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i <= 5; i++) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + " " + i);
        }
    }
}