package multithreading;

/*
При запуске одной и той же программы с несколькими потоками можно наблюдать разный output.
Т.е. заранее невозможно знать какая часть первого потока сначала обработается, когда
начнет работать другой поток, когда он перехватит инициативу и тд. Все это зависит от
ряда моментов: сколько свободных ядер у процессора в данный момент времени, какова
их загруженность и тд. При решении большинство задач очень важно, чтобы соблюдалась
упорядоченность в действии потоков. Это достигается за счет их синхронизации.

Ключевое слово volatile (c англ. изменчивый, непостоянный).

Пример-задание на использование ключевого слова volatile.
В одном потоке работает цикл, который необходимо закончить из другого потока изменив
переменную с true на false.
*/

public class Volatile extends Thread {
    volatile boolean b = true;

    @Override
    public void run() {
        long counter = 0;
        while(b) {
            counter++;
        }
        System.out.println("Loop is finished. Counter = " + counter);
    }

    public static void main(String[] args) throws InterruptedException {
        Volatile thread = new Volatile();
        thread.start();
        // Нужно, чтобы цикл поработал 3 секунды, поэтому вызывается метод sleep
        Thread.sleep(3_000);
        /* Метода sleep вызван был для потока main (public static void main),
        а не для потока thread (thread.sleep(3_000);)
        */
        System.out.println("After 3 seconds it is time to wake up!");

        // меняется значение переменной b c true на false
        thread.b = false;

        // ниже строкой ожидание завершения потока при помощи метода join
        thread.join();

        System.out.println("End of program");
        // Вывод:
        // After 3 seconds it is time to wake up!
        // цикл не остановился и программа была остановлена вручную

        /*
        Почему так произошло, что переменная b не приняла значение false и цикл в
        переопределенном методе run не остановился?

        public class Main extends Thread {
            boolean b = true;

            @Override
            public void run() {
                long counter = 0;
                while(b) {
                    counter++;
                }
                System.out.println("Loop is finished. Counter = " + counter);
            }

            public static void main(String[] args) throws InterruptedException {
                Main thread = new Main();
                thread.start();
                // Нужно, чтобы цикл поработал 3 секунды, поэтому вызывается метод sleep
                Thread.sleep(3_000);
                // Метода sleep вызван был для потока main (public static void main),
                // а не для потока thread (thread.sleep(3_000);)
                System.out.println("After 3 seconds it is time to wake up!");
                // меняется значение переменной b c true на false
                thread.b = false;
                // ниже строкой ожидание завершения потока при помощи метода join
                thread.join();
                System.out.println("End of program");

        В многопоточных программах, где потоки работают с переменными, каждый поток
        может скопировать значение переменной из общей памяти, которая называется
        Main Memory (она содержит значение переменных).

        CPU1

                ->                          ->
        thread       CPU1 cache (b = true;)
                <-                          <-
                                                                MAIN
                                                               MEMORY
        CPU2
                                                              (b = true;)
                ->                                  ->
        main         CPU1 cache (b = true / false;)
                <-                                  <-


        Каждый поток может скопировать значение переменных, в данном случае одной
        переменной - b, в кэш CPU.
        Как в примере выше, есть два потока tread и main. Они работают на разных
        ядрах процессора и для ускорения работы с переменными они могут скопировать
        значения этих переменных, каждый в свой кэш CPU. Это производится для быстрого
        доступа, т.к. кэш - это очень быстрая область памяти. Чтобы ядру каждый раз
        не обращаться к общей памяти у него есть свой кэш, он копирует значение
        переменных туда.
        Как происходила работы в примере выше:
        была создана переменная b и эта переменная равна true. Соответственно, в
        кэш CPU1 thread и в кэш CPU2 main помещается переменная b со значением true
        В какой-то момент времени, а именно через 3 секунды в потоке main меняется
        значение для переменной b c true на false. Это значение хранится в кэше CPU2,
        который работает с потоком main и САМЫЙ ГЛАВНЫЙ ФАКТ заключается в том, что
        невозможно узнать, когда измененное значение переменной b в потоке main
        попадет в Main Memory и кэш CPU1, с которым работает потока thread, прочитает
        это измененное значние и изменить его у себя тоже.
        В примере выше возника ситуация, когда во всех областях памяти включая Main Memory
        переменная b = true. Когда происходит изменение переменной b c true на false
        оно меняется только в кеше CPU2, с которым работает поток main, а в кэше
        CPU1 находится прежнее значение - true, т.к. кэш CPU1 "общается" с
        Main Memory, а Main Memory не получило от кэша CPU2 обновленное значение
        переменной b. Поэтому, цикл из примера выше продолжает "крутиться" даже после
        того, как в потоке main изменилось значение переменной b c true на false.
        Чтобы избежать этой ситуации необходимо использовать ключевое слово volatile
        для переменной. Когда переменная volotile, то ее значение будет храниться только
        в Main Memory. Кэш CPU1 (поток thread) и кэш CPU2 (поток main) не будут хранить
        значение переменной b. И когда потоку thread или потоку main нужно будет
        поработать с переменной b, они будут напрямую обращаться не к своему кэшу,
        а к Main Memory. В этом и суть ключевого слова volatile. Переменные volatile
        хранятся не в кэше, а только в Main Memory (в основной памяти) и тогда
        ресинхронизации в значении данной переменной среди потоков не будет.
        Чтобы сделать переменную volatile необходимо перед ее типом указать ключевое
        слово volatile.

        В самом верхнем примере (с использованием ключевого слова volatile), main поток спит
        3 секунды (Thread.sleep(3_000);), поэтому for loop в методе run класса Volatile
        while(b) {
            counter++;
        }
        работает 3 секунды. После чего main поток просыпается и выводит сообщение
        "After 3 seconds it is time to wake up!", меняет переменную b c true на
        false (thread.b = false;), после чего поток thread узнает об этом и цикл
        останавливается. Далее выводится сообщение "Loop is finished. Counter = 4785201876",
        за эти 3 секунды переменная counter стала равной 4_785_201_876. И в итоге,
        после того, как поток main дождался окончания потока thread (thread.join();)
        выводит на экран сообщение "End of program".

        Ключевое слово volatile используется для пометки переменной, как хранящейся
        только в основной памяти "Main Memory".

         ВАЖНОЕ ЗАМЕЧАНИЕ!
        Для синхронизации значения переменной между потоками ключевое слово volatile
        используется тогда, когда только один поток может изменять значение этой
        переменной, а остальные потоки могут его только читать.

        Представим, что теперь работа происходит не с переменной типа boolean, а с
        переменной типа int.
        volatile int i = 0;
        Значение этой переменной будет храниться только в
        Main Memory. CPU1 и CPU2 cache использоваться не будет. И представим, что
        оба потока thread и main выполняют операцию "i++". Эта операция не атомарная,
        т.е. эта операция состоит из нескольких частей.
        Чтобы увеличить переменную i необходимо:
        1. Прочесть текущее значение, в данном случае из Main Memory;
        2. Прочтенное значение увеличить;
        3. Записать новое значение в Main Memory;
        Т.е. операция i++ состоит из трех шагов.
        Оба потока выполняют эту операцию в каком-то цикле, например, 100 раз выполняет
        первый поток эту операцию и 100 раз второй. Может возникнуть ситуация, допустим,
        переменная i уже была увеличена до значения 5. Первый поток, чтобы
        выполнить операцию i++ прочитал значение 5 из Main Memory. А потоки то работают
        параллельно. В этот момент второй поток тоже читает это значение, которое равное
        5 и начинает проводить свою операцию. Первый поток увеличил значение переменной
        на 1 и записал в Main Memory новое значение переменной i. Теперь значение
        переменной a в Main Memory равно 6. Второй поток заканчивает свою работу, т.е.
        значение, которое ранее он прочитал увеличил на 1, в итоге второй поток тоже
        пытается записать результат равный 6 в Main Memory. Но ожидалось, что оба потока
        сработают и значение переменной должно увеличиться на 2. Т.е. было значение 5, оба
        потока увеличили на 1 это значение и в итоге должно было получиться значение 7.
        Но значение 7 не будет, потому что эти потоки работают параллельно и может
        возникнуть ситуация, которая описана выше. Таким образом volatile хорошо
        справляется со своей работой, когда только один поток меняет значение, а
        остальные читают. Для достижения синхронизации потоков, когда несколько из
        них могут менять значение переменной используются другие техники синхронизации.
        */
    }
}