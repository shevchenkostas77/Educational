package multithreading.thread_safe;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/*
Когда необходима коллекция, с которой будут работать больше одного потока, то можно выбрать между двумя вариантами:
1. Synchronized collections - получаются из традиционных коллекций благодаря их обертыванию;
2. Concurrent collections - изначально созданы для работы с многопоточностью;

Synchronized collections - это те коллекции, которые получаются из not-synchronized коллекции. Например, из коллекции
ArrayList. Класс Collections (не интерфейс, а класс) предоставляет для работы с многопоточностью wrapper-ы, т.е.
обертки. Эти обертки будут оборачивать коллекции, такие как: ArrayList, HashMap и другие.

        Collections.synchronizedXYZ(коллекция)

При помощи класса Collections вызывается метод synchronized (это первая часть имени), вместо XYZ будут писаться такие
слова, как List (synchronizedList), Map (synchronizedMap), Set (synchronizedSet) и тд. Т.е. до этого классическая
коллекция не могла работать с многопоточностью, но обернувшись в обертку - такая возможность появляется. Synchronized
коллекции достигают потокобезопасности благодаря тому, что используют lock через synchronized блоки для всех методов.
Это означает, что если, допустим, несколько потоков захотят добавить элемент в ArrayList, а какие-то потоки захотят
удалить из этого ArrayList-a элементы, то в ArrayList будет доступ только по одному потоку. Сначала первый поток
поработает, сделает необходимые ему операции, допустим, добавит элемент и только после того, как первый поток закончит
все свои дела с коллекцией (снимет блокировку), только после этого второй поток сможет добавить свои элементы. Т.е.
первый поток когда заходит, он ставит lock и пока он не закончит работу, lock не снимается. Performance, т.е.
производительность бывает не очень хорошая потому, что постоянно ставятся Lock-и, а это занимает время, многие потоки
стоят в очереди и ждут. Т.е. производительность у Concurrent collections, как правило, намного выше, чем Synchronized
collections, ведь Concurrent collections были созданы конкретно для работы с многопоточностью. А Synchronized
collections получаются из обычных коллекций с помощью из доработки (их обертки).
 */