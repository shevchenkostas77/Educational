package multithreading.interface_lock_and_reentrant_lock_class;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/*
Метод tryLock() - "попытайся сделать lock". Когда поток пытается выполнить lock,
а его уже выполнил какой-то другой поток, тогда второй поток просто начинает ждать, когда
ему выпадет возможность сделать lock, т.е. поставить замок. Пока первый поток не откроет
замок, второй не может закрыть замок. Метода tryLock() работает по-другому, если замок
открыт, то tryLock закроет этот замок, т.е. выполнится тот же lock. Если же замок закрыт,
т.е. код обрабатывается каким-то другим потоком, к примеру, thread1, тогда у потока,
к примеру, thread2 не получается сделать lock (он пытается, но не получается) и тогда
поток thread2 продолжает выполнять свой последующий код. Т.е. поток thread2 в область
кода, который нужно выполнять учитывая синхронизацию вообще не заходит и не зайдет.
*/

public class InterfaceLockAndReentrantLockClass3 {
    public static void main(String[] args) throws InterruptedException {

        Lock lock = new ReentrantLock();

        new Employee("Zaur", lock);
        new Employee("Oleg", lock);
        new Employee("Elena", lock);

        Thread.sleep(5_000);
        new Employee("Victor", lock);
        new Employee("Marina", lock);

        /*
        Запуск программы. Вывод:

        Zaur не хочет ждать в очереди
        Elena пользуется банкоматом
        Oleg не хочет ждать в очереди
        Elena завершил(а) свои дела
                                        (Для наглядности тут пробел)
        Victor пользуется банкоматом
        Marina не хочет ждать в очереди
        Victor завершил(а) свои дела

        Елена начала пользоваться банкоматом, эти вещи обрабатываются одновременно:

                Zaur не хочет ждать в очереди
                Elena пользуется банкоматом
                Oleg не хочет ждать в очереди

        просто сообщение "Zaur не хочет ждать в очереди" вышло первым. На самом деле
        Елена заняла банкомат, т.е. она сначала поставила lock, после этого Заур
        увидел, что банкоматом кто-то пользуется, поэтому он не хочет ждать в очереди.
        Далее Олег тоже увидел, что банкомат занят и он тоже не хочет ждать в очереди.
        Ниже выводится сообщение, что Елена завершила свои дела. Через определенное
        время Виктор увидел, что банкоматом никто не пользуется, поэтому он стал им
        пользоваться, а Марина "подошла" и видит, что банкомат занят и она не хочет
        ждать в очереди. Ну, и на конец, Виктор завершил свои дела.
        Метод tryLock позволяет делать lock когда ресурс свободен или делать что-то
        другое (} else {) когда ресурс занят.
        */
    }
}

//class Employee extends Thread {
//    String name;
//    private Lock lock;
//
//    public Employee(String name, Lock lock) {
//        this.name = name;
//        this.lock = lock;
//        this.start(); // после создания объекта сразу запускается поток
//    }
//
//    @Override
//    public void run() {
//        if(lock.tryLock()) {
//        /* tryLock возвращает boolean (если удалось залочить, то возвращает true,
//        иначе возвращает false)
//        */
//            try {
//                // System.out.println(name + " ждет...");
//                // lock.lock();
//                // когда поток заходит в код, это означет, что работник пользуется банкоматом
//                System.out.println(name + " пользуется банкоматом");
//                Thread.sleep(3_000); // имитация пользования банкоматом
//                System.out.println(name + " завершил(а) свои дела");
//            } catch (InterruptedException e) {
//                e.printStackTrace();
//            } finally {
//                lock.unlock();
//            }
//        } else {
//            System.out.println(name + " не хочет ждать в очереди");
//        }
//    }
    /*
    Логика программы такая, если банкоматом никто не пользуется, тогда работник начинает
    пользоваться им, завершает свои дела и тд. Если же ему не удалось поставить замок -
    if(lock.tryLock()) {, т.е. банкоматом в даннй момент кто-то пользуется, то выводится
    сообщение, что такой-то работник не хочет ждать в очереди.
    */
//}