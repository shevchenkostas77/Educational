package multithreading;

/*
Монитор - это специальный механизм, благодаря которому достигается корректная работа
при синхронизации. В Java у каждого объекта и класса есть привязанная к ним сущность,
которая называется "монитор". Монитор может иметь статус "Свободен" или "Занят", именно
этот механизм используется в Java, когда пишется в коде ключевое слово synchronized.
Таким образом, когда один поток заходит в область кода, который помечен как synchronized,
монитор объекта или класса принимает состояние "Занято". В одно и то же время монитор может
заниматься только одним потоком и никакой другой поток до того, как монитор снова не станет
свободным, не сможет работать с этим кодом. Если будет, к примеру, три потока (Т1, Т2, Т3)
и они попытаются исполнить синхронизированный код, то только один из них, например, Т2 первым
сможет занять монитор и пока этот поток, Т2, не освободит монитор, потоки Т1 и Т3 будут ждать.
После они будут бороться за монитор, кто из них первым займет монитор, тот и обработает
synchronized code. Логика вот такова.
Другими словами, когда монитор становится занятым - происходит lock, т.е. ставится замок -
"запираются двери" для остальных потоков. Когда единственный поток делающий работу в
synchronized коде заканчивает ее и lock снимается, монитор становится свободным до тех
пор, пока следующий поток не заберется в synchronized код. Т.е. "закрывается дверь",
когда монитор занят, когда монитор становится свободным "открываются двери" для других
потоков и какой первый из потоков зайдет, т.е. займет монитор, тот и будет работать с
synchronized кодом. Суть такова.
ВАЖНЫЙ МОМЕНТ!
Любая блокировка с помощью синхронизации идет на объекте или на классе, а не на каком-то
коде, т.е. идет синхронизация, используя монитор объекта или класса (синхронизация идет на
этом уровне благодаря монитору объекта или монитору класса). У метода, да, возможно написать
synchronized методы, но у метода нет никакого монитора, для синхронизации метода используется
мониторы объекта или класса.

Монитор - это сущность/механизм, благодаря которому достигается корректная работа при
синхронизации. В Java у каждого класса и объекта есть привязанный к нему монитор.
*/

/*
В принципе synchronized blocks работают так же как и synchronized methods, только обычно
синхронизируют не весь код в методе, а лишь его часть.
*/

public class MonitorAndSynchronizedBlocks {
    public static void main(String[] args) {

        MyRunnableImpl runnable = new MyRunnableImpl();

        Thread thread1 = new Thread(runnable);
        Thread thread2 = new Thread(runnable);
        Thread thread3 = new Thread(runnable);

        thread1.start();
        thread2.start();
        thread3.start();

        /*
        class Counter2 {
            volatile static int count = 0;
        }

        class MyRunnableImpl implements Runnable {
            private synchronized void doWork1() {
                Counter2.count++;
                System.out.println(Counter2.count);
            }

            @Override
            public void run() {
                for (int i = 0; i < 3; i++) {
                    doWork1();
                }
            }
        }
        Вывод:
        1
        2
        3
        4
        5
        6
        7
        8
        9
        Метод doWork1 - synchronized поэтому все вывелось, как должно было вывестись
        используя синхронизацию.
        */

        /*
        Теперь будет не синхронизированный метод в классе MyRunnableImpl, а
        синхронизированный блок. Будет тоже использоваться слово synchronized и пишется
        это слово внутри метода doWork1. Открываются скобки и внутри скобок пишется
        объект, на котором будем синхронизироваться, т.е. объект, чей монитор для
        синхронизации будет использоваться. Пусть это будет this и помещается код,
        который будет синхронным в фигурные скобки.

        ДО:
        class MyRunnableImpl implements Runnable {
            private synchronized void doWork1() {
                Counter2.count++;
                System.out.println(Counter2.count);
            }

        ПОСЛЕ:
        class MyRunnableImpl implements Runnable {
            private void doWork1() {
                synchronized(this) {
                    Counter2.count++;
                    System.out.println(Counter2.count);
                }
            }
        this - объект или название класса на которое будет синхронизация, т.е. чей
        монитор будет использоваться, чей монитор будет lock и unlock в конце кода.
        И эти две строчки кода будут синхронизированными:
            Counter2.count++;
            System.out.println(Counter2.count);
        Тут синхронизация будет происходить на объекте this, т.е. когда вызывается
        метод doWork1, он не статичный, поэтому перед тем, как его вызвать необходимо
        создать объект MyRunnableImpl.
        Если запустить этот измененный код,
        Вывод:
        1
        2
        3
        4
        5
        6
        7
        8
        9
        в принципе никаких отличий от того случая, в котором использовался синхронизированный
        метод нет. Потому, что весь код, который находится в методе doWork1 синхронизирован.
        Таким же способом ключевое слово synchronized было вставлено в метод doWork1 и
        все работало так же.
        Возникает вопрос, использует ли какой-нибудь монитор synchronized методы?
        Т.е., когда тут:
            public synchronized void doWork1() {
        пишется ключевое слово synchronized монитор какого-то объекта или класса используется?
        Да, конечно иначе просто никак! Когда используются synchronized методы, то явно этот
        объект или класс не указывается. А когда используется synchronized blocks в скобках
        необходимо указать монитор какого объекта будет использоваться для синхронизации.
        Когда происходит работа с synchronized методами, если метод не статичный, то всегда
        идет синхронизация на объекте this.

        В чем отличие synchronized methods от synchronized blocks?
        Самое главное отличие synchronized block в том, что можно синхронизировать не весь
        метод, а его часть. Например, есть еще один метод в классе MyRunnableImpl:

            class MyRunnableImpl implements Runnable {

            private void doWork2() {
                System.out.println("Ura!!!");
            }

            private void doWork1() {
                doWork2();
                // private потому, что метод doWork1 вызывается только в MyRunnableImpl
                synchronized (this) {
                    Counter2.count++;
                    System.out.println(Counter2.count);
                }
            }

            @Override
            public void run() {
                for (int i = 0; i < 3; i++) {
                    doWork1();
                }
            }
        }

        в методе doWork1 вызывается метод doWork2. В методе doWork1 часть кода не синхронизирована
        (до ключевого слова synchronized) и часть кода синхронизирована с помощью синхронизированного
        блока (после ключевого слова synchronized). Т.е. когда несколько потоков захотят обратиться к
        методу doWork1, они все стазу заходят в этот метод, все одновременно могут работать с методом
        doWork2, но когда дело дойдет до синхронизированного блока, то в него может попасть одновременно
        только один поток, все остальные будут ждать. Т.е. если есть уверенность, что часть кода в методе
        doWork1, а именно выполнение метода doWork2 не может вызвать какие-то проблемы,  типа Data race,
        то почему бы не дать возможность эту часть кода выполнить сразу нескольким потокам. А когда
        дело доходит до блока когда, когда необходимо, чтобы потоки работали по одному, то этот код
        необходимо заключить в synchronized block. Это основное отличие synchronized methods от
        synchronized blocks.
        Если небольшой метод, который полностью должен быть синхронизированным, то лучше использовать
        ключевое слово synchronized в сигнатуре метода. Когда внутри метода необходимы участки кода,
        которые будут синхронизированный, а какие-то нет, то необходимо использовать synchronized блоки.
        Если запустить этот пример,
        Вывод:
        Ura!!!
        Ura!!!
        Ura!!!
        1
        Ura!!!
        2
        Ura!!!
        3
        4
        Ura!!!
        5
        Ura!!!
        6
        7
        Ura!!!
        8
        Ura!!!
        9

        какая-то часть кода, а именно метод doWork2, может выполняться сразу несколькими потоками
        одновременно, а когда дело доходит синхронизированной части кода, то тут уже только один поток
        в одно и тоже время может выполнять эту синхронизированную часть кода.



        */

    }
}

class Counter2 {
    volatile static int count = 0;
}

class MyRunnableImpl implements Runnable {

    private void doWork2() {
        System.out.println("Ura!!!");
    }

    private void doWork1() {
        doWork2();
        // private потому, что метод doWork1 вызывается только в MyRunnableImpl
        synchronized (this) {
            Counter2.count++;
            System.out.println(Counter2.count);
        }
    }

    @Override
    public void run() {
        for (int i = 0; i < 3; i++) {
            doWork1();
        }
    }
}