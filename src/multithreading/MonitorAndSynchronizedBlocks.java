package multithreading;

/*
Монитор - это специальный механизм, благодаря которому достигается корректная работа
при синхронизации. В Java у каждого объекта и даже у класса есть привязанная к
ним сущность, которая называется "монитор". Монитор может иметь статус "Свободен"
или "Занят", именно этот механизм используется в Java, когда пишется в коде ключевое
слово synchronized. Таким образом, когда один поток заходит в область кода, который
помечен как synchronized, монитор объекта или класса принимает состояние "Занято". В
одно и то же время монитор может заниматься только одним потоком и теперь больше никакой
поток до того, как монитор опять не станет свободным не сможет работать с этим кодом.
Если будет, к примеру, три потока (Т1, Т2, Т3) и они попытаются исполнить синхронизированный
код, только один из них, например, Т2 первым сможет занять монитор и пока этот поток, Т2,
не освободит монитор, потоки Т1 и Т3 будут ждать. После они будут бороться за монитор,
кто из них первым займет монитор, тот и обработает synchronized code. Логика вот такова.
Другими словами, когда монитор становится занятым происходит lock, т.е. ставится замок,
"запираются двери" для остальных потоков. Когда единственный поток делающий работу в
synchronized коде заканчивает работу lock снимается, монитор становится свободным до тех
пор, пока следующий поток не заберется в synchronized код, т.е. "закрывается дверь",
когда монитор занят, когда монитор становится свободным "открываются двери" для других
потоков и какой первый из потоков зайдет, займет монитор, тот и будет работать с
synchronized кодом. Суть такова.
ВАЖНЫЙ МОМЕНТ!
Любая блокировка с помощью синхронизации идет на объекте или на классе, а не на каком-то
коде, т.е. идет синхронизация, используя монитор объекта или класса (синхронизация идет на
этом уровне благодаря монитору объекта или монитору класса). У метода, да, возможно написать
synchronized методы, но у метода нет никакого монитора, для синхронизации метода используется
мониторы объекта или класса.

Монитор - это сущность/механизм, благодаря которому достигается корректная работа при
синхронизации. В Java у каждого класса и объекта есть привязанный к нему монитор.
*/

/*
В принципе synchronized blocks работают так же как и synchronized methods, только обычно
синхронизируют не весь код в методе, а лишь его часть.
*/

public class MonitorAndSynchronizedBlocks {
    public static void main(String[] args) {

        MyRunnableImpl runnable = new MyRunnableImpl();

        Thread thread1 = new Thread(runnable);
        Thread thread2 = new Thread(runnable);
        Thread thread3 = new Thread(runnable);

        thread1.start();
        thread2.start();
        thread3.start();

        /*
        class Counter2 {
            volatile static int count = 0;
        }

        class MyRunnableImpl implements Runnable {
            public synchronized void doWork1() {
                Counter2.count++;
                System.out.println(Counter2.count);
            }

            @Override
            public void run() {
                for (int i = 0; i < 3; i++) {
                    doWork1();
                }
            }
        }
        Вывод:
        1
        2
        3
        4
        5
        6
        7
        8
        9
        Метод doWork1 - synchronized поэтому все вывелось, как должно было вывестись
        используя синхронизацию.
        */

        /*
        Изменим, теперь будет не синхронизированный метод в классе MyRunnableImpl, а
        синхронизированный блок. Будет тоже использоваться слово synchronized и пишется
        это слово внутри метода doWork1. Открываются скобки и внутри скобок пишется
        объект, на котором будем синхронизироваться, т.е. объект, чей монитор для
        синхронизации будет использоваться. Пусть это будет this и помещается код,
        который будет синхронным в фигурные скобки.

        ДО:
        class MyRunnableImpl implements Runnable {
            public synchronized void doWork1() {
                Counter2.count++;
                System.out.println(Counter2.count);
            }

        ПОСЛЕ:
        class MyRunnableImpl implements Runnable {
            public void doWork1() {
                synchronized(this) {
                    Counter2.count++;
                    System.out.println(Counter2.count);
                }
            }
        this - объект или название класса на которое будет синхронизация, т.е. чей
        монитор будет использоваться, чей монитор будет lock и unlock в конце кода.
        И эти две строчки кода будут синхронизированными:
            Counter2.count++;
            System.out.println(Counter2.count);
        Тут синхронизация будет происходить на объекте this, т.е. когда вызывается
        метод doWork1, он не статичный, поэтому перед тем, как его вызвать необходимо
        создать объект MyRunnableImpl.
        Если запустить этот измененный код,
        Вывод:
        1
        2
        3
        4
        5
        6
        7
        8
        9
        в принципе никаких отличий от того случая, в котором использовался синхронизированный
        метод нет. Потому, что весь код, который находится в методе doWork1 синхронизирован.
        Таким же способом ключевое слово synchronized было вставлено в метод doWork1 и
        все работало так же.
        Возникает вопрос, использует ли какой-нибудь монитор synchronized методы?
        Т.е., когда тут:
            public synchronized void doWork1() {
        пишется ключевое слово synchronized монитор какого-то объекта или класса используется?
        Да, конечно иначе просто никак! Когда используются synchronized методы, то явно этот
        объект или класс не указывается. А когда используется synchronized blocks в скобках
        необходимо указать монитор какого объекта будет использоваться для синхронизации.
        Когда происходит работа с synchonized методами, если метод не статичный, то всегда
        идет синхронизация на объекте this.

        В чем отличие synchronized methods от synchonized blocks?
        Самое главное отличие synchonized block в том, что можно синхронизировать не весь
        метод, а его часть. Например, есть еще один метод в классе MyRunnableImpl:

        */

    }
}

class Counter2 {
    volatile static int count = 0;
}

class MyRunnableImpl implements Runnable {


    private void doWork1() {
        // private потому, что метод doWork1 вызывается только в MyRunnableImpl
        synchronized(this) {
            Counter2.count++;
            System.out.println(Counter2.count);
        }
    }

    @Override
    public void run() {
        for (int i = 0; i < 3; i++) {
            doWork1();
        }
    }
}
