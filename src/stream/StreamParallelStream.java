package stream;

import java.util.List;
import java.util.ArrayList;

/*
Вообще, когда происходит работа со stream, by default, используются последовательные потоки,
т.е. sequential stream. Пока самостоятельно вручную не указать Java, что необходимо
использовать parallel stream, Java будет использовать sequential stream.

Parallel stream - это возможность использования нескольких ядер процессора при выполнении
каких-либо операций со stream.

Допустим, есть какой-то stream, который содержит множество элементов, к примеру
1, 2, 3, 4 ... 1_000_000_000 (от одного до миллиарда чисел содержит поток)
и необходимо с помощью stream вычислить, к примеру, произведение элементов stream-a.
Если запустить sequential (последовательный) stream, то происходит последовательная работа, т.е.
1 умножается на 2, после результат умножается на 3, далее результат умножается на 4 и
так процесс происходит до миллиарда.
Если запустить parallel stream и процессор компьютера имеет несколько ядер, т.е. многоядерный,
то тогда Java запускает процесс немного иначе, чем при sequential (последовательной) работе.
К примеру, процессор имеет четыре ядра, на котором будет происходить вычисление произведения
от 1 до 1_000_000_000 тогда (возможен вариант, это предполагаемый пример):
- ядро №1 перемножает числа от 1 до 250_000_000;
- ядро №2 перемножает числа от 250_000_001 до 500_000_000;
- ядро №3 перемножает числа от 500_000_001 до 750_000_000;
- ядро №4 перемножает числа от 750_000_001 до 1_000_000_000;
Выходит, что четыре ядра работают одновременно. В итоге, у ядра №1 свой результат, у ядра №2 свой
результат, у ядра №3 свой результат, у ядра №4 свой результат и далее эти четыре числа  (результата)
перемножаются между собой, что в конечном итоге должно сработать гораздо быстрее, чем работа
процессора с одним ядром с использованием sequential stream.
Суть parallel stream - разбить большое задание на несколько небольших подзаданий, выполнить параллельно
эти подзадания и в конечном итоге объединить результаты подзаданий в один конечный результат.
Чтобы использовать parallel stream, многопоточность применять не нужно, все это делает Java сама, а
программист пишет всего одну команду, чтобы выполнялся parallel streaming.

Методы Stream не меняют саму коллекцию или массив, от которой был создан stream.
*/

public class StreamParallelStream {
    public static void main(String[] args) {
        List<Double> list = new ArrayList<>();
        list.add(10.0);
        list.add(5.0);
        list.add(1.0);
        list.add(0.25);

        /*
        Сделать stream параллельным можно двумя способами:

        1. На этапе получения потока из готовой любой коллекции вместо метода stream необходимо
        воспользоваться методом parallelStream, к примеру:

            list.parallelStream(). ...

        2. Когда создается stream "с нуля" на этом stream-e вызывается метод parallel:

            Stream<T> name = Stream.of(...);
            name.parallel(). ...
        */

        /*
        Использование parallel stream подходит для каких-то агрегированных функций (нахождение минимума,
        максимума или суммы) и когда этих элементов очень много. Если же элементов, к примеру 10, 50 или 100,
        то использование параллельности даже навредит (увеличит немного время выполнения задания), т.к.
        задание нужно поделить между параллельными потоками, собрать воедино результат каждого
        выполненного задания отдельного ядра, а на это тоже уходит время.
        Не подходит, когда действия над элементами напрямую зависит от их очередности (ниже
        приведен пример).
        */

        double sumResultWithoutParallelStream = list.stream()
                .reduce((accumulator, element) -> accumulator + element)
                .get();
        System.out.println("Sum without parallel stream = " + sumResultWithoutParallelStream);
        // Вывод:
        // Without parallel stream = 16.25

        double sumResultWithParallelStream = list.parallelStream()
                .reduce((accumulator, element) -> accumulator + element)
                .get();
        System.out.println("Sum with parallel stream = " + sumResultWithParallelStream);
        // Вывод:
        // With parallel stream = 16.25
        /*
        Java внутренне решает на сколько потоков поделить stream, чтобы они выполнялись параллельно.
        В обоих вариантах получается корректное значение потому, что от перемены мест слагаемых сумма
        не меняется.
        */

        double divisionResultWithoutParallelStream = list.stream()
                .reduce((accumulator, element) -> accumulator / element)
                .get();
        System.out.println("Division without parallel stream = " + divisionResultWithoutParallelStream);
        // Вывод:
        // Division without parallel stream = 8.0

        double divisionResultWithParallelStream = list.parallelStream()
                .reduce((accumulator, element) -> accumulator / element)
                .get();
        System.out.println("Division with parallel stream = " + divisionResultWithParallelStream);
        // Вывод:
        // Division with parallel stream = 0.5 - НЕКОРРЕКТНЫЙ РЕЗУЛЬТАТ
        /*
        Использование parallel streaming при делении получился некорректный результат.
        Можно предположить, что данное задание было поделено на две части:
        1. деление 10 / 5 = 2;
        2. деление 1 / 0.25 = 4;
        Результирующие частные были разделены между собой 2 / 4 = 0.5
        В такого рода задании, где порядок элементов очень влияет на результат ни в коем
        случае использовать parallel streaming ИСПОЛЬЗОВТЬ НЕЛЬЗЯ!
        */

        /*
        Пример 1. В нашем компьютере 1 CPU, и, допустим, 1 ядро. Если Вы хотите, чтобы вашу
        задачу выполняли 4 потока, то все эти 4 потока будут работать на одном ядре, что крайне
        неэффективно. Эффективней было бы вообще эту задачу не делить между потоками, а
        предоставить её выполнять одному единственному потоку.
        Пример 2. В нашем компьютере 1 CPU, и, допустим, 4 ядра. Теперь каждый поток может
        выполняться на отдельном ядре, и задача может быть выполнена в 4 раза быстрее.
        Т.е. поток выполняется с помощью функциональности ядра, который является частью CPU.
       */
    }
}